Write your first test
Patrol is a powerful, open-source testing framework created by LeanCode that enhances Flutter's testing capabilities by enabling interaction with native platform features directly in Dart. It allows to handle permission dialogs, notifications, WebViews, and device settings‚Äîfeatures previously unavailable in standard Flutter tests, making it truly possible to test the whole app.

This tutorial will take you through writing your first substantial Patrol test, interacting both with the Flutter app itself and also with native permission dialogs and notifications.

Before writing any tests, make sure you install the Patrol CLI. Then just clone the following repository from GitHub to follow along. The app we‚Äôre going to be testing is fully functional and ready to be tested, with Patrol already configured.

To learn how to set up Patrol for your own project, check out the Patrol Setup Docs.

Clone the STARTER PROJECT to follow along.


App Walkthrough
Before we can start writing automated Patrol tests, we need to know what the app does and to test it manually. Please, check out the video tutorial for a visual walkthrough.

The first screen of our app is for signing in. It‚Äôs not using any actual sign-in provider but it only validates the email address and password. In order to successfully ‚Äúsign in‚Äù and get to the home screen, we need to input a valid email and a password that‚Äôs at least 8 characters long.

You can test any real authentication providers that use WebView for signing in with the powerful Patrol native automation.

On the second screen, we‚Äôre greeted with a notifications permission dialog. Once we allow them, we can tap on the notification button in the app bar to manually trigger a local notification which will be displayed after 3 seconds both when the app is running in the foreground or in the background.

Once we open the native notification bar and tap on the notification from our app, we‚Äôre gonna see a snackbar on the bottom saying "Notification was tapped!‚Äù

Testing the ‚ÄúHappy Path‚Äù
You‚Äôve just seen the full walkthrough of the app, including errors that can show up if you input an invalid email or password. UI tests (integration tests), like the ones we‚Äôre going to write with Patrol, should only be testing the ‚Äúhappy path‚Äù of a UI flow. We only want them to fail if the app suddenly stops the user from doing what the app is for - in this case, that‚Äôs displaying a notification. Validation error messages are not ‚Äúwhat the app is for‚Äù, they exist only to allow the user to successfully sign in with a proper email and password. That‚Äôs why we won‚Äôt be checking for them in the tests.

Writing the Test
We have only one UI flow in this app, that is signing in, showing the notification and then tapping on that notification. This means, we‚Äôre going to have only a single test. Let‚Äôs create it in /integration_test/app_test.dart.

Like any other test, we need to have a main() top-level function. Inside it we‚Äôre going to have our single patrolTest with a description properly describing what we‚Äôre about to test. An optional step is to set the frame policy to ‚Äúfully live‚Äù to make sure all frames are shown, even those which are not pumped by our test code. Without it, we would see that our app stutters and animations are not played properly.


import 'package:flutter_test/flutter_test.dart';
import 'package:patrol/patrol.dart';

void main() {
  patrolTest(
    'signs in, triggers a notification, and taps on it',
    framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
    ($) async {
      // Test code will go here
    },
  );
}
We could start writing the test right now and then re-run it from scratch every time we add a new line of test code by calling patrol test --target integration_test/app_test.dart but since we‚Äôre writing a Patrol test that runs on an Android or iOS device, constantly building the whole Flutter app is not time effective. Thankfully, Patrol offers a different approach - hot restarting the tests! We can run the command patrol develop --target integration_test/app_test.dart right now and anytime we add a new line of test code, we can just type ‚Äúr‚Äù in the terminal to re-run the tests without the time-costly app building. Just make sure that you have an emulator running first - Patrol will select it automatically.

First, we need to perform any initializations that need to happen before the app is run and pump the top-level widget of our app. We‚Äôre effectively doing what the main function inside main.dart does - this time not for just running the app as usual but for running an automated Patrol test.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
  },
);
Hot-restarting the test by typing ‚Äúr‚Äù into the terminal won‚Äôt really do much since we‚Äôre not yet performing any user-like actions but you will at least see the sign in page for a brief moment before the test finishes.

Let‚Äôs now perform some action! We know we have to sign in if we want to continue to the home screen. First, we have to type in both email and password. There are multiple ways to find widgets on the screen - by widget type, by text and lastly by key.

Although it‚Äôs not the best practice, we‚Äôre first going to find the fields by type. Both are of type TextFormField but there are two of them on the screen so the following won‚Äôt work.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(TextFormField).enterText('test@email.com');
    await $(TextFormField).enterText('password');
  },
);
That‚Äôs because finders always find the first matching widget so both the email address and password are entered into the same field - in this case, the email field.

If multiple widgets on a screen match the finder, we can tell Patrol which one we want by specifying its index in the list of all found widgets from top to bottom like this:


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(TextFormField).enterText('test@email.com');
    await $(TextFormField).at(1).enterText('password');
  },
);
We can use a text finder to tap on the ‚ÄúSign in‚Äù button.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(TextFormField).enterText('test@email.com');
    await $(TextFormField).at(1).enterText('password');
    await $('Sign in').tap();
  },
);
Hot-restarting the test will now take you all the way to the home page from which we will want to trigger the notification.

As you can imagine though, using type and text finders in any app that‚Äôs just a bit more complex will result in a huge mess. The recommended approach is to always find your widgets by their Key. There are currently no keys specified for these widgets so let‚Äôs change that. In sign_in_page.dart pass in the following into the TextFormFields and ElevatedButton:


class SignInPage extends StatelessWidget {
  const SignInPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      ...
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              TextFormField(
                key: const Key('emailTextField'),
                decoration: const InputDecoration(
                  labelText: 'Email',
                ),
                ...
              ),
              const SizedBox(height: 16),
              TextFormField(
                key: const Key('passwordTextField'),
                decoration: const InputDecoration(
                  labelText: 'Password',
                ),
                ...
              ),
              const SizedBox(height: 16),
              Builder(builder: (context) {
                return ElevatedButton(
                  key: const Key('signInButton'),
                  ...
                  child: const Text('Sign in'),
                );
              }),
            ],
          ),
        ),
      ),
    );
  }
}
With the keys in place, we can now rewrite our test code to use Key finders. The simplest approach is to prefix the key‚Äôs value with a hash symbol. For this approach to work, your keys mustn‚Äôt contain any invalid characters such as spaces.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(#emailTextField).enterText('test@email.com');
    await $(#passwordTextField).enterText('password');
    await $(#signInButton).tap();
  },
);
Looking at this test code again, it‚Äôs certain we can do better. Why? We‚Äôve just added code duplication to our codebase! The key values in sign_in_page.dart and in app_test.dart are fully duplicated and if we change one, the other won‚Äôt be automatically updated, thus breaking our tests.

That‚Äôs why production-grade apps should have a single source for all the Keys exposed as a global final variable inside integration_test_keys.dart. That‚Äôs going to look as follows if we already take into account the home page which we want to test next.


import 'package:flutter/foundation.dart';

class SignInPageKeys {
  final emailTextField = const Key('emailTextField');
  final passwordTextField = const Key('passwordTextField');
  final signInButton = const Key('signInButton');
}

class HomePageKeys {
  final notificationIcon = const Key('notificationIcon');
  final successSnackbar = const Key('successSnackbar');
}

class Keys {
  final signInPage = SignInPageKeys();
  final homePage = HomePageKeys();
}

final keys = Keys();
Feel free to put your page-specific key classes (e.g. SignInPageKeys) into separate files in more complex apps.

The updated sign_in_page.dart code will now look like this:


class SignInPage extends StatelessWidget {
  const SignInPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      ...
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              TextFormField(
                key: keys.signInPage.emailTextField,
                decoration: const InputDecoration(
                  labelText: 'Email',
                ),
                ...
              ),
              const SizedBox(height: 16),
              TextFormField(
                key: keys.signInPage.passwordTextField,
                decoration: const InputDecoration(
                  labelText: 'Password',
                ),
                ...
              ),
              const SizedBox(height: 16),
              Builder(builder: (context) {
                return ElevatedButton(
                  key: keys.signInPage.signInButton,
                  ...
                  child: const Text('Sign in'),
                );
              }),
            ],
          ),
        ),
      ),
    );
  }
}
The test code will now also use the keys global final variable instead of the hash symbol notation:


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(keys.signInPage.emailTextField).enterText('test@email.com');
    await $(keys.signInPage.passwordTextField).enterText('password');
    await $(keys.signInPage.signInButton).tap();
  },
);
Hot-restarting the test won‚Äôt show any change in its functionality but it sure is more maintainable and easier to work with.

Home Page
First, let‚Äôs add the keys we‚Äôve already created to the IconButton and the SnackBar shown when the notification has been tapped.


class HomePage extends StatefulWidget {
  ...
}

class _HomePageState extends State<HomePage> {
  ...

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home'),
        actions: [
          IconButton(
            key: keys.homePage.notificationIcon,
            icon: const Icon(Icons.notification_add),
            onPressed: () {
              triggerLocalNotification(
                onPressed: () {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      key: keys.homePage.successSnackbar,
                      content: const Text('Notification was tapped!'),
                    ),
                  );
                },
                onError: () {
                  ...
                },
              );
            },
          ),
        ],
      ),
      ...
    );
  }
}
The first thing the user sees when first navigating to the HomePage is a notifications permission dialog. We need to accept it from within the test. Patrol‚Äôs native automation makes this as easy as it gets.

Native automation allows you to interact with the OS your Flutter app is running on. Patrol currently supports Android, iOS and macOS native interactions. Learn more from the docs


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(keys.signInPage.emailTextField).enterText('test@email.com');
    await $(keys.signInPage.passwordTextField).enterText('password');
    await $(keys.signInPage.signInButton).tap();
    await $.native.grantPermissionWhenInUse();
  },
);
Hot-restarting the test will work wonderfully the first time, however, once the permission has already been granted, calling grantPermissionWhenInUse() will fail. This is not going to be an issue if you use Patrol as a part of your CI/CD process since everytime you test with Patrol there, the app will be built from scratch and no permission will be granted yet. But when we‚Äôre writing the test locally with patrol develop command, we need to make sure that the permission dialog is visible before trying to accept it.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(keys.signInPage.emailTextField).enterText('test@email.com');
    await $(keys.signInPage.passwordTextField).enterText('password');
    await $(keys.signInPage.signInButton).tap();
    if (await $.native.isPermissionDialogVisible()) {
      await $.native.grantPermissionWhenInUse();
    }
  },
);
It‚Äôs generally a bad practice to add any branching logic within your tests and you should be 100% certain that it cannot introduce any test flakiness before doing so. Checking if a permission dialog is visible is an example of a proper use of branching logic.

Next up, we want to tap on the notification icon button and then go to the device home screen to test the notification while the app is running in the background.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
	  initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(keys.signInPage.emailTextField).enterText('test@email.com');
    await $(keys.signInPage.passwordTextField).enterText('password');
    await $(keys.signInPage.signInButton).tap();
    if (await $.native.isPermissionDialogVisible()) {
      await $.native.grantPermissionWhenInUse();
    }
    await $(keys.homePage.notificationIcon).tap();
    await $.native.pressHome();
  },
);
Once we‚Äôre on the home screen, we want to open the notification shade and tap on the notification we get from our app. You can either tap on a notification by index or by finding a text. We know that the title of our notification is ‚ÄúPatrol says hello!‚Äù so let‚Äôs do the latter.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
    initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(keys.signInPage.emailTextField).enterText('test@email.com');
    await $(keys.signInPage.passwordTextField).enterText('password');
    await $(keys.signInPage.signInButton).tap();
    if (await $.native.isPermissionDialogVisible()) {
      await $.native.grantPermissionWhenInUse();
    }
    await $(keys.homePage.notificationIcon).tap();
    await $.native.pressHome();
    await $.native.openNotifications();
    await $.native.tapOnNotificationBySelector(
      Selector(textContains: 'Patrol says hello!'),
    );
  },
);
Since the notification is delayed by 3 seconds, we have to provide a timeout that‚Äôs at least as long in order to wait for the notification to appear - 5 seconds should do the trick here.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
    ...
    await $.native.openNotifications();
    await $.native.tapOnNotificationBySelector(
      Selector(textContains: 'Patrol says hello!'),
      timeout: const Duration(seconds: 5),
    );
  },
);
Lastly, we want to check if the snackbar has been shown after tapping on a notification. We can call waitUntilVisible() after selecting it with its key.


patrolTest(
  'signs in, triggers a notification, and taps on it',
  framePolicy: LiveTestWidgetsFlutterBindingFramePolicy.fullyLive,
  ($) async {
    initApp();
    await $.pumpWidgetAndSettle(const MainApp());
    await $(keys.signInPage.emailTextField).enterText('test@email.com');
    await $(keys.signInPage.passwordTextField).enterText('password');
    await $(keys.signInPage.signInButton).tap();
    if (await $.native.isPermissionDialogVisible()) {
      await $.native.grantPermissionWhenInUse();
    }
    await $(keys.homePage.notificationIcon).tap();
    await $.native.pressHome();
    await $.native.openNotifications();
    await $.native.tapOnNotificationBySelector(
      Selector(textContains: 'Patrol says hello!'),
      timeout: const Duration(seconds: 5),
    );
    $(keys.homePage.successSnackbar).waitUntilVisible();
  },
);
And just like that, we have now tested the whole flow of the app with Patrol! If any part of the logic breaks, this test will notify us about that sooner than our real users do and that‚Äôs what we‚Äôre all after!
Logs and test results
Once you've written and executed your tests, it's essential to monitor their results. Patrol provides two main methods for reporting test outcomes: console logs and native test reports.

Logging test steps
This feature is available starting from version 3.13.0.

If you're using this version but don't see logs for test steps, check if you're passing a custom PatrolTesterConfig to patrolTest(). If so, ensure the printLogs: true argument is included in the constructor.

During test execution, every test step (e.g., tap or enterText) is logged to the console along with its status. Additionally, the test name, status, and execution time are displayed.

Example console output:


...
üß™ denies various permissions
        ‚úÖ   1. scrollTo widgets with text "Open permissions screen".
        ‚úÖ   2. scrollTo widgets with text "Open permissions screen".
        ‚úÖ   3. tap widgets with text "Open permissions screen".
        ‚úÖ   4. tap widgets with text "Request camera permission".
        ‚úÖ   5. isPermissionDialogVisible (native)
        ‚úÖ   6. tap widgets with text "Request camera permission".
        ‚úÖ   7. isPermissionDialogVisible (native)
        ‚è≥   8. denyPermission (native)
‚ùå denies various permissions (integration_test/permissions/deny_many_permissions_twice_test.dart) (9s)
‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY FLUTTER TEST FRAMEWORK ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following PlatformException was thrown running a test:
PlatformException(PermissionHandler.PermissionManager, A request
for permissions is already running, please wait for it to finish
before doing another request (note that you can request multiple
permissions at the same time)., null, null)

When the exception was thrown, this was the stack:
#0      StandardMethodCodec.decodeEnvelope (package:flutter/src/services/message_codecs.dart:648:7)
#1      MethodChannel._invokeMethod (package:flutter/src/services/platform_channel.dart:334:18)
<asynchronous suspension>
#2      MethodChannelPermissionHandler.requestPermissions (package:permission_handler_platform_interface/src/method_channel/method_channel_permission_handler.dart:79:9)
<asynchronous suspension>
#3      PermissionActions.request (package:permission_handler/permission_handler.dart:52:31)
<asynchronous suspension>
#4      _PermissionsScreenState._requestCameraPermission (package:e2e_app/permissions_screen.dart:21:20)
<asynchronous suspension>

The test description was:
  denies various permissions
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚úÖ taps on notification (integration_test/permissions/notifications_test.dart) (16s)
‚úÖ taps on notification native2 (integration_test/permissions/notifications_test.dart) (14s)
‚úÖ grants various permissions (integration_test/permissions/permissions_many_test.dart) (15s)
...
Test summary
Once the tests are complete, a summary is printed:


Test summary:
üìù Total: 8
‚úÖ Successful: 3
‚ùå Failed: 5
  - taps on notification (integration_test/permissions/notifications_test.dart)
  - taps on notification native2 (integration_test/permissions/notifications_test.dart)
  - accepts location permission (integration_test/permissions/permissions_location_test.dart)
  - accepts location permission native2 (integration_test/permissions/permissions_location_test.dart)
  - grants various permissions (integration_test/permissions/permissions_many_test.dart)
‚è© Skipped: 0
üìä Report: file:///Users/user/patrol/dev/e2e_app/build/app/reports/androidTests/connected/index.html
‚è±Ô∏è  Duration: 227s
Customizing log behavior
You can customize which logs are displayed by using the following flags. These can be passed to the patrol test or patrol develop commands:

Flag	Description	Available in	Default value
--[no-]show-flutter-logs	Show Flutter logs while running the tests.	patrol test, in patrol develop it's always on	false
--[no-]hide-test-steps	Hide test steps while running the tests.	patrol test and patrol develop	false
--[no-]clear-test-steps	Clear test steps after the test finishes.	patrol test	true
Native test reports
In addition to console logs, you can review test results in a native test report. The report's file path is provided in the test summary, for example:


üìä Report: file:///Users/user/patrol/dev/e2e_app/build/app/reports/androidTests/connected/index.html
Logs in patrol_finders
By default, enhanced logs are disabled when using patrol_finders without the patrol package. To enable them, pass the printLogs: true argument to the PatrolTesterConfig constructor:


patrolWidgetTest(
  'throws exception when no widget to tap on is found',
  config: const PatrolTesterConfig(printLogs: true),
  (tester) async {
    // test body
    // ...
  },
);

testWidgets(
  'description',
  (widgetTester) async {
    final $ = PatrolTester(
      tester: widgetTester,
      config: PatrolTesterConfig(printLogs: true),
    );
    // test body
    // ...
  },
);

Patrol finders - overview
Flutter's finders are powerful, but not very intuitive to use.

We took them and made something awesome.

Thanks to Patrol's custom finders, you'll take your tests from this:


testWidgets('signs up', (WidgetTester tester) async {
  await tester.pumpWidget(AwesomeApp());
  await tester.pumpAndSettle();

  await tester.enterText(
    find.byKey(Key('emailTextField')),
    'charlie@root.me',
  );
  await tester.pumpAndSettle();

  await tester.enterText(
    find.byKey(Key('nameTextField')),
    'Charlie',
  );
  await tester.pumpAndSettle();

  await tester.enterText(
    find.byKey(Key('passwordTextField')),
    'ny4ncat',
  );
  await tester.pumpAndSettle();

  await tester.tap(find.byKey(Key('termsCheckbox')));
  await tester.pumpAndSettle();

  await tester.tap(find.byKey(Key('signUpButton')));
  await tester.pumpAndSettle();

  expect(find.text('Welcome, Charlie!'), findsOneWidget);
});
to this:


patrolWidgetTest('signs up', (PatrolTester $) async {
  await $.pumpWidgetAndSettle(AwesomeApp());

  await $(#emailTextField).enterText('charlie@root.me');
  await $(#nameTextField).enterText('Charlie');
  await $(#passwordTextField).enterText('ny4ncat');
  await $(#termsCheckbox).tap();
  await $(#signUpButton).tap();

  await $('Welcome, Charlie!').waitUntilVisible();
});
Patrol finders - usage
This page introduces Patrol finder system. Let's get our hands dirty and find some widgets!

Finding widgets
Let's say you want to find some Text widget ‚Äì nothing easier than that!


find.byType(Text);
Using Patrol finder, you'd write the above as:


$(Text);
Or let's find a Text widget with a specific text:


find.text('Subscribe');
Using Patrol finder, you'd write the above as:


$('Subscribe');
Worth mentioning is also Key. The below lines are equivalent:


find.byKey(Key('loginButton'));
$(Key('loginButton'));
$(#loginButton);
For those wondering what is that # thing ‚Äì it's a Symbol! Yes, we're Dart (ab)users.

All the types that can be passed to $ are listed here.
Making assertions
Creating a finder doesn't do anything ‚Äì it just is. Let's put them to use and write a few simple assertions.

Here's how you can make sure that a widget with text Log in exists in the widget tree:


expect(find.text('Log in'), findsOneWidget);
With our Patrol finders, you'd write the above as:


expect($('Log in'), findsOneWidget);
Alternatively, you could also use the exists getter, which returns true if the finder finds at least 1 widget:


expect($('Log in').exists, equals(true));
We can also make sure that no widget exists, or that a particular number of widgets exist:


expect(find.text("Can't touch this"), findsNothing);
expect(find.byType(Card), findsNWidgets(3));
The above expressed with Patrol finders:


expect($("Can't touch this"), findsNothing);
expect($(Card), findsNWidgets(3));
You could alternatively write the first line as:


expect($("Can't touch this").exists, equals(false));
It's important to note that Flutter's default finder functions, such as findsNothing and findsOneWidget, check if the widget is present in the widget tree, not if it is visible to the user, which is usually not what we're interested in.

To check if the finder finds at least 1 visible widget, use the visible getter:


expect($('Log in').visible, equals(true));
And to wait for at least 1 widget with the "Log in" text to become visible:


await $('Log in').waitUntilVisible();
Performing actions
Finding widgets alone is cool, but what's even cooler is being able to tap on them! Let's tap on the first "Subscribe" text:


await tester.tap(find.text('Subscribe').first);
It's usually a good practice to use first, because if there were multiple "Subscribe" texts, tap() would throw an exception.

With Patrol, you get concise code, but you preserve the flexibility:


await $('Subscribe').tap();
What's very cool about Patrol's tap() is that it doesn't immediately fail if the finder finds no visible widgets ‚Äì instead, it waits for some time (which you can specify globally in PatrolTesterConfig or as argument to the tap() method) and taps on the first widget as soon as it becomes visible. This lets you get rid of fixed timeouts and test your app just like a real user would.

If you wanted to tap on the third "Subscribe" text, you'd do:


await $('Subscribe').at(2).tap();
And if the "Subscribe" text was in a Scrollable widget, such as SingleChildScrollView or ListView, and you want to make sure that it is visible (so you can tap() on it), you can scroll to it very easily:


await $('Subscribe').scrollTo().tap();
Going deeper
But hey, these were very simple examples. In real apps, unfortunately, finding widgets is not that easy.

Often, you'll need to tap on a widget which is in some other widget.


await tester.tap(
  find.descendant(
    of: find.byType(ListView),
    matching: find.text('Subscribe'),
  ).first
);
Flutter's finders are starting to grow, while Patrol stays lean:


await $(ListView).$('Subscribe').tap();
Now, we also make sure that the Subscribe text is in a ListTile:


await tester.tap(
  find.descendant(
    of: find.byType(ListView),
    matching: find.descendant(
      of: find.byType(ListTile),
      matching: find.text('Subscribe'),
    ),
  ).first
);
Hey, this is starting to look complex! Fortunately, you have Patrol:


await $(ListView).$(ListTile).$('Subscribe').tap();
Sometimes, you might want to perform a lookahead check. Let's say that you want tap on the first widget with the Key('learnMore') that is a descendant of some ListTile, but that ListTile must also have the Text descendant with the Activated text.

If you were to express the above as a Finder, you'd get:


await tester.tap(
  find.ancestor(
    of: find.text('Activated'),
    matching: find.descendant(
      of: find.byType(ListTile),
      matching: find.byKey(Key('learnMore')),
    ),
  ).first
);
With the help of Patrol's custom finders, it's much easier:


await $(ListTile).containing('Activated').$(#learnMore).tap();
Sometimes, however, the logic required to find a widget cannot be expressed by the descendant/ancestor relationship like above. In situations like this, when all ways of finding widgets known to you fail, Patrol has an ace up its sleeve: the which() method. You can use it to find widgets by their properties. A few examples include: .

entering a text into a text field with no text entered:


await $(#cityTextField)
    .which<TextField>((widget) => widget.controller.text.isNotEmpty)
    .enterText('Warsaw, Poland');
asserting that the icon has the correct color:


await $(Icons.error)
    .which<Icon>((widget) => widget.color == Colors.red)
    .waitUntilVisible();
asserting that the button is disabled and has the correct color


await $('Delete account')
  .which<ElevatedButton>((button) => !button.enabled)
  .which<ElevatedButton>(
    (btn) => btn.style?.backgroundColor?.resolve({}) == Colors.red,
  )
  .waitUntilVisible();

Falling back
What's cool about Patrol is that it builds on top of flutter_test instead of replacing it. This means that you can freely mix Patrol's finders with finders from flutter_test, PatrolTester with WidgetTester, and so on.

Here's how you can access the default WidgetTester:


patrolWidgetTest('adds comment', (PatrolTester $) async {
  final WidgetTester tester = $.tester;

  await tester.enterText(find.byKey(Key('commentTextField')), 'Very nice!');
});
atrol finders - advanced
We aim to make Patrol as simple as possible, but there are still a few matters that we feel require some more attention. We'll explain them in this section.

How is Patrol's tap() different from Flutter's tap()?
Let's consider this test, written without Patrol:


await tester.tap(find.byKey(Key('addComment')).first);
await tester.pumpAndSettle();
This code:

Immediately atttempts to find the first widget with the addComment key
After finding the widget, it immediately attempts to tap on it
This is the default behavior, but in our experience, it's often a source of flakiness. For example, the widget having addComment key might not be visible at the time when the finder is run. This usually doesn't means that the test should fail. Probably an HTTP request was made to fetch the post, and when the fetching is done, the widget having addComment key will show up.

To achieve this behavior, you'd have to do:


while (find.byKey(Key('addComment')).first.evaluate().isEmpty) {
  await tester.pump(Duration(milliseconds: 100));
}

await tester.tap(find.byKey(Key('addComment')).first);
await tester.pumpAndSettle();
Our tiny example got really big, but it's still got two problems.

If something goes wrong and addComment never shows up, we'll keep waiting indefinitely.

The widget with addComment key might be present in the widget tree, but still not be visible to the user. By default, Flutter's default WidgetTester doesn't care. This is almost never desirable.

Fortunately, you don't have to overcome these problems. Patrol already did it!

Below is the same test, with all the above problems fixed, written with Patrol's custom finders:


await $(#addComment).tap();
This code:

Attempts to find the first widget with addComment that is visible on screen. If it's not found immediately, it keeps trying until it finds it, or throws an exception if timeout.
Taps on it.
The timeout can be configured globally:


patrolWidgetTest(
  'logs in successfully',
  config: PatrolTestConfig(findTimeout: Duration(seconds: 10)),
  ($) async {
  // your test code
  },
);
You can also change the timeout ad-hoc:


await $(#addComment).tap(findTimeout: Duration(seconds: 30));
You gotta pump it up! But which one to use?
In Flutter, "pumping" means rendering frames to the screen.

If there are no frames to pump, no animations are pending, which usually means that the next action during the test can be executed. It is an equivalent of what a human tester would do while testing an app - they would wait until the app's state stabilizes after they've done something. For example, they tap on a button and get redirected to another screen, but the data that will be shown there hasn't been loaded yet. In such a case, a human tester waits until a loader (or other animation) finishes. Pumping mechanism does exactly this - it renders consecutive frames on the screen. For how long, exactly? Usually, we want to pump frames as long as they come. That's what pumpAndSettle() does.

pumpAndSettle() method is called by default inside all actions that can be performed while testing - tapping, scrolling, entering text, and so on. You can change that by setting the settlePolicy argument:


await $('Delete account').tap(settlePolicy: SettlePolicy.settle);
await $('Confirm').tap(settlePolicy: SettlePolicy.pump);
SettlePolicy is an enum with 3 values. The default is SettlePolicy.settle but you can change it to pump or trySettle. Those values map to methods like this:

noSettle -> pump(),
trySettle -> pumpAndTrySettle(),
settle -> pumpAndSettle().
While settle and pump simply refer to Flutter's built-in methods, trySettle is available only in Patrol. How is it different from other ones?

pumpAndTrySettle() is pretty much like pumpAndSettle(), the only difference is that pumpAndSettle() throws an exception, if there were still new frames to render after sonme defined timeout, while pumpAndTrySettle() does not. That's why it has "try" in it's name.

When to use this new pumping method? Let us picture a scenario, in which we have to deal with some animations. Let's say, that your app has some endless animations, e.g. on a homescreen, to keep user's attention. You'd like to wait for some things to happen, but using pumpAndSettle, you'll keep getting an exception, because after some time, defined by timeout, there will be still new frames to render. On the other hand, you still want to pump frames for some time - if you didn't, the screen you want to interact with might not be rendered yet, or it would have some widgets missing or data not yet loaded.

So, we decided to add a way to try settle - pump frames for some time (10 seconds by default), but if after that time there is still something new to render - do nothing and continue the test.

We recommend using pumpAndTrySettle(), because it works with both kinds of animations - finite and infinite. This settle policy will be new default in future Patrol releases.

How does scrollTo() work?
The scrollTo() method is simple to use, yet very powerful. Here's how you use it to scroll to and tap on the first widget with the "Delete account" text:


await $('Delete account').scrollTo().tap();
And here's how scrollTo() works:

Waits for at least 1 Scrollable widget (or whatever you provided in view argument) to become visible
Scrolls this widget in its scrolling direction until the target widget becomes visible
If the target widget becomes visible within timeout, it finishes, otherwise it throws an exception
Most of the time, you use scrollTo() and it just works, but there's 1 important thing to keep in mind when using scrollTo():

scrollTo(), by default, scrolls the first Scrollable widget

This default is reasonable and what you want most of the time. Unfortunately, this behavior can sometimes cause problems in more complicated UIs, where more than a single Scrollable widget is visible at the same time. In such cases we strongly recommend explicitly specifying the view that scrollTo() should scroll, to avoid the problem of the target widget never becoming visible because the wrong widget was scrolled.

To demonstrate this problem, let's consider this very simple app:


class App extends StatelessWidget {
  App({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Column(
          children: [
            Expanded(child: ListView(key: Key('listView1'))),
            Expanded(
              child: ListView.builder(
                key: Key('listView2'),
                itemCount: 101,
                itemBuilder: (context, index) => Text('index: $index'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
Now let's say that you're writing a test and want to scroll to and tap on the first widget with the "index: 100" text (that is the last Text widget built by the second ListView widget):

There's a high chance that you'd write this:


await $('index: 100').scrollTo().tap();
Unfortunately, running this test gives the pumpAndSettle timed out error. That's because the scrollTo() was trying to scroll the first visible Scrollable widget, which happens to be the first ListView (the one with listView1 key and no children).

To fix this problem, you have to explicitly specify which Scrollable you want to use:


await $('index: 100').scrollTo(view: $(#listView2).$(Scrollable)).tap();
The above snippet will scroll the second Scrollable and find the widget with "index: 100" text.

Why so verbose?

You might be wondering why scrollTo(view: $(#listView2)) is not enough? Why is it needed to look for a Scrollable widget inside the widget with the listView2 key?

This is because the ListView widget doesn't extend Scrollable ‚Äì instead, it builds a subclass of Scrollable itself. This is a known Flutter problem.

Native automation - overview
Flutter's integration_test does a good job at providing basic support for integration testing Flutter apps. What it can't do is interaction with the OS your Flutter app is running on. This makes it impossible to test many critical business features:

granting runtime permissions
signing into the app which uses WebView or 0Auth (like Google) as the login page
listing and tapping on notifications
exiting the app, coming back, and verifying that state is preserved
enabling and disabling features such as Wi-Fi, mobile data, location, or dark mode
Patrol's native automation feature finally solves these problems. Here's a tiny snippet to spice things up:

integration_test/demo_test.dart

void main() {
  patrolTest('demo', (PatrolIntegrationTester $) async {
    await $.pumpWidgetAndSettle(AwesomeApp());
    // prepare network conditions
    await $.native.enableCellular();
    await $.native.disableWifi();

    // toggle system theme
    await $.native.enableDarkMode();

    // handle native location permission request dialog
    await $.native.selectFineLocation();
    await $.native.grantPermissionWhenInUse();

    // tap on the first notification
    await $.native.openNotifications();
    await $.native.tapOnNotificationByIndex(0);
  });
}

Native automation - usage
Once set up, interacting with the native UI using Patrol is very easy!

Basics
After you've got your NativeAutomator object, you simply call methods on it and it does the magic.

To tap on a native view (for example, a button in a WebView):


await $.native.tap(Selector(text: 'Sign up for newsletter'));
To enter text into a native view (for example, a form in a WebView):


await $.native.enterText(
  Selector(text: 'Enter your email'),
  text: 'charlie@root.me',
);
You can also enter text into n-th currently visible text field (counting from 0):


await $.native.enterTextByIndex('charlie_root', index: 0); // enter username
await $.native.enterTextByIndex('ny4ncat', index: 1); // enter password
The above are the simplest, most common actions, but they already make it possible to test scenarios that were impossible to test before, such as WebViews.

To tap, enter text, or perform generally any UI interaction with a iOS app that is not your Flutter app under test, you need to pass its bundle identifier. For example, to tap on the plus button in the iPhone contacts app, use:


await $.native.tap(
  Selector(text: 'Add'),
  appId: 'com.apple.MobileAddressBook',
);
Notifications
To open the notification shade:


await $.native.openNotifications();
To tap on the second notification:


await $.native.tapOnNotificationByIndex(1);
You can also tap on notification by its content:


await $.native.tapOnNotificationBySelector(
  Selector(textContains: 'Someone liked your recent post'),
);

Permissions
To handle the native permission request dialog:


await $.native.grantPermissionWhenInUse();
await $.native.grantPermissionOnlyThisTime();
await $.native.denyPermission();

If the permission request dialog visible is the location dialog, you can also select the accuracy:


await $.native.selectFineLocation();
await $.native.selectCoarseLocation();

The test will fail if the permission request dialog is not visible. You can check if it is with:


if (await $.native.isPermissionDialogVisible()) {
  await $.native.grantPermissionWhenInUse();
}
By default, isPermissionDialogVisible() waits for a short amount of time and then returns false if the dialog is not visible. To increase the timeout:


if (await $.native.isPermissionDialogVisible(timeout: Duration(seconds: 5))) {
  await $.native.grantPermissionWhenInUse();
}
Patrol can handle permissions on iOS only if the device language is set to English (preferably US). That's because there's no way to refer to a specific view in a language-independent way (like resourceId on Android).

If you want to handle permissions on iOS device with non-English locale, do it manually:


await $.native.tap(
  Selector(text: 'Allow'),
  appId: 'com.apple.springboard',
);
More resources
To see more integration tests demonstrating Patrol's various features, check out our example app.


Native automation - advanced
Patrol section in pubspec.yaml
If your app has different name on iOS and Android, you can specify app_name twice ‚Äì one in android block, and one in ios block.

Though the whole Patrol section in pubspec.yaml is optional, we highly recommend adding this section, because it enables the following features:

Patrol will automatically uninstall your app after every test (using package_name and bundle_id). This will make the environment which your tests run in more stable and predictable.
Patrol will be able to tap on your app's notifications (using app_name)
Specific version of patrol_cli
You can install a specific version of Patrol CLI. For example:


dart pub global activate patrol_cli ^1.0.0
will install the latest v1 version. We recommend to install a specific version on CI systems to avoid unexpected breakages.

Isolation of test runs
To achieve full isolation between test runs, enable the clearPackageOption:

android/app/build.gradle

defaultConfig {
    //...
    testInstrumentationRunner "pl.leancode.patrol.PatrolJUnitRunner"
    testInstrumentationRunnerArguments clearPackageData: "true"
}
This will clear the app's data and permissions before each test run. Unfortunately, no equivalent feature is available on iOS.

Embrace the native tests
If you've diligently followed the steps in native automation setup and patrol test prints a TEST PASSED message, you might be now thinking: what did I just do?

The answer is: You've just integrated Flutter testing with native Android/iOS testing frameworks. This means that your Flutter integration tests can now be run as native tests.

What are native tests good for, anyway?
iOS and Android have existed for more than 15 years, and during that time many of awesome testing-related things were built around them ‚Äì open-source test runners, device farms, HTML report generators. Developers who create native mobile apps can easily reap benefits from this huge, mature ecosystem.

Meanwhile we, Flutter developers, don't have as much at our disposal. Our framework is much younger and less mature.

What if we could masquerade our Flutter tests so that from the outside they would be truly native? This way we leverage many existing tools while maintaining the convenience of writing the tests in pure Dart.

For example, you can run your Patrol tests directly from Xcode. Xcode knows nothing about Flutter, Dart and Patrol ‚Äì it only launches your test app. Flutter tests are then run inside the test app and the results are reported back to Xcode. This way you get the best of both worlds ‚Äì the maturity of native iOS development and the productivity of Flutter and Dart.

That's exactly what Patrol does (and what the default integration_test package does at well, but at a bit smaller scale).

Take a look at this simple Flutter integration tests using Patrol:

integration_test/example_test.dart

void main() {
  patrolTest(
    'counter state is the same after going to Home and switching apps',
    nativeAutomatorConfig: NativeAutomatorConfig(
      packageName: 'pl.leancode.patrol.example',
      bundleId: 'pl.leancode.patrol.Example',
    ),
    ($) async {
      await $.pumpWidget(ExampleApp());

      await $(FloatingActionButton).tap();
      expect($(#counterText).text, '1');

      await $.native.pressHome();
      await $.native.openApp();

      expect($(#counterText).text, '1');

      await $(FloatingActionButton).tap();
      expect($(#counterText).text, '2');
    },
  );
}

Effective Patrol
Over the past months, we've written many Patrol tests and often learned the hard way what works well and what doesn't. We're sharing our findings hoping that they'll help you write robust tests.

This document follows RFC 2119.
PREFER using keys to find widgets
Patrol's custom finders are very powerful, and you might often be inclined to find the widget you want in a variety of ways. While we're encouraging you to explore and play with Patrol's custom finders, we are quite confident that keys are the best way to find widgets.

Why not strings?

At first, strings might seem like a good way to find widgets.

They'll get increasingly annoying to work with as your app grows and changes, for example, when the strings in your app change.

Using strings stops making any sense when you have more than 1 language in your app. Using strings in such case is asking for trouble.

Why not classes?

There are 2 problems with using classes.

First is that they hurt your test's readability. You want to tap on the login button or enter text into the username field. You don't want to tap on, say, the third button and enter text into the second text field.

The second problem is that classes are almost always an implementation detail. As a tester, you shouldn't care if something is a TextButton or an OutlineButton. You care that it is the login button, and you want to tap on it. In most cases, that login button should have a key.

Let's consider this simple example:


await $(LoginForm).$(Button).at(1).tap(); // taps on the second ("login") button
This works, but the code is not very self-explanatory. To make it understandable at glance, you had to add a comment.

But if you assigned a key to the login button, the above could be simplified to:


await $(#loginButton).tap();
Much better!

Let's see another example:


await $(Select<String>).tap(); // taps on the first Select<String>
If the type parameter is changed from String to, for example, some specialized PersonData model, that finder won't find anything. You'd have to update it to:


await $(Select<PersonTile>).tap();
You had to change your test, even though nothing changed from the user's perspective. This is usually a sign that you rely too much on classes to find widgets.

This whole section could be summed up to the simple maxim:

Have tester's mindset.

Treat your finders as if they were the tester's eyes.

CONSIDER having a file where all keys are defined
The number of keys will get bigger as your app grows and you write more tests. To keep track of them, it's a good idea to keep all keys in, say, lib/keys.dart file.

lib/keys.dart

import 'package:flutter/foundation.dart';

typedef K = Keys;

class Keys {
  const Keys();

  static const usernameTextField = Key('usernameTextField');
  static const passwordTextField = Key('passwordTextField');
  static const loginButton = Key('loginButton');
  static const forgotPasswordButton = Key('forgotPasswordButton');
  static const privacyPolicyLink = Key('privacyPolicyLink');
}
Then you can use it in your app's and tests' code:

In app UI code

@override
Widget build(BuildContext context) {
  return Column(
    children: [
      /// some widgets
      TextField(
        key: K.usernameTextField,
        // some other TextField properties
      ),
      // more widgets
    ],
  );
}
In app test code

void main() {
  patrolTest('logs in', (PatrolIntegrationTester $) {
    // some code
    await $(K.usernameTextField).enterText('CoolGuy');
    // more code
  });
}
This is a good way to make sure that the same keys are used in app and tests. No more typos!

PREFER having one test path
Good tests test one feature, and test it well (this applies to all tests, not only Patrol tests). This is often called the "main path". Try to introduce as little condional logic as possible to help keep the main path straight. In practice, this usually comes down to having as few ifs as possible.

Keeping your test code simple and to the point will also help you in debugging it.

DO add a good test description explaining the test's purpose
If your app is non-trivial, your Patrol test will become long pretty quickly. You may be sure now that you'll always remember what the 200 line long test you've just written does and are (rightfully) very proud of it.

Believe us, in 3 months you will not remember what your test does. This is why the first argument to patrolTest is the test description. Use it well!


// GOOD
import 'package:awesome_app/main.dart';
import 'package:patrol/patrol.dart';

void main() {
  patrolTest(
    'signs up for the newsletter and receives a reward',
    ($) async {
      await $.pumpWidgetAndSettle(AwesomeApp());

      await $(#phoneNumber).enterText('800-555-0199');
      await $(#loginButton).tap();

      // more code
    },
  );
}

// BAD
void main() {
  patrolTest(
    'test',
    ($) async {
      await $.pumpWidgetAndSettle(AwesomeApp());

      await $(#phoneNumber).enterText('800-555-0199');
      await $(#loginButton).tap();

      // more code
    },
  );
}

Handling permission dialogs before the main app widget is pumped
Sometimes you might want to manually request permissions in the test before the main app widget is pumped. Let's say that you're using the geolocator package:


final permission = await Geolocator.requestPermission();
final position = await Geolocator.getCurrentPosition();
await $.pumpWidgetAndSettle(MyApp(position: position));
In such case, first call the requestPermission() method, but instead of awaiting it, assign the Future it returns to some final. Then, use Patrol to grant the permissions, and finally, await the Future from the first step:


// 1. request the permission
final permissionRequestFuture = Geolocator.requestPermission();
// 2. grant the permission using Patrol
await $.native.grantPermissionWhenInUse();
// 3. wait for permission being granted
final permissionRequestResult = await permissionRequestFuture;
expect(permissionRequestResult, equals(LocationPermission.whileInUse));
final position = await Geolocator.getCurrentPosition();
await $.pumpWidgetAndSettle(MyApp(position: position));

leancodepl/patrolLight logo
Patrol

Search...
‚åò
K
leancodepl/patrol
1,048
158
Toggle theme
Overview
Documentation
CLI commands
Patrol Feature Guide
Articles & Resources
Discord
patrol API reference
patrol_finders API reference
CLI commands
develop
test
build
doctor
update
devices
Commands - test
Synopsis
Run integration tests.


patrol test
To see all available options and flags, run patrol test --help.

Description
This command is the one use you'll be using most often.

patrol test does the following things:

Builds the app under test (AUT) and the instrumentation app
Installs the AUT and the instrumentation on the selected device
Runs the tests natively, and reports results back in native format.
Under the hood, it calls Gradle (when testing on Android) and xcodebuild (when testing on iOS).

Discussion
By default, patrol test runs all integration tests (files ending with _test.dart located in the integration_test directory).

To run a single test, use --target:


patrol test --target integration_test/login_test.dart
You can use --target more than once to run multiple tests:


patrol test \
  --target integration_test/login_test.dart \
  --target integration_test/app_test.dart
Or alternatively:


patrol test --targets integration_test/login_test.dart,integration_test/app_test.dart
Test files must end with _test.dart. Otherwise the file is not considered a test and is not run.

There's no difference between --target and --targets.
To delay app uninstallation for 5 seconds after the test finishes:


patrol test --target integration_test/app_test.dart --wait 5
Tags
You can use tags to run only tests with specific tags.

First specify tags in your patrol tests:


  patrol(
    'example test with tag',
    tags: ['android'],
    ($) async {
      await createApp($);

      await $(FloatingActionButton).tap();
      expect($(#counterText).text, '1');
    },
  );

  patrol(
    'example test with two tags',
    tags: ['android', 'ios'],
    ($) async {
      await createApp($);

      await $(FloatingActionButton).tap();
      expect($(#counterText).text, '1');
    },
  );
Then you can run tests with the tags you specified:


patrol test --tags android
patrol test --tags=android
patrol test --tags='android||ios'
patrol test --tags='(android || ios)'
patrol test --tags='(android && tablet)'
You can also use --exclude-tags to exclude tests with specific tags:


patrol test --exclude-tags android
patrol test --exclude-tags='(android||ios)'
Coverage
Coverage collection is currently not supported on macOS.

To collect coverage from patrol tests, use --coverage.


patrol test --coverage
The LCOV report will be saved to /coverage/patrol_lcov.info.

Additionally, you can exclude certain files from the report using glob patterns and --coverage-ignore option. For instance,


patrol test --coverage --coverage-ignore="**/*.g.dart"
excludes all files ending with .g.dart.

Under the hood
patrol test basically calls patrol build and then runs the built app binaries. For more info, read docs of patrol build.

Edit this page on GitHub
develop
build
Powered by
‚¨°
invertase/docs.page
On this page
Synopsis
Description
Discussion
Tags
Coverage
Under the hood
Commands - test