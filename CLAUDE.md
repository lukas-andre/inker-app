# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Inker Studio is a Flutter mobile application for iOS and Android that connects tattoo artists with customers. The app uses Clean Architecture with BLoC pattern for state management and Freezed for immutable models.

## Essential Commands

### Code Generation (Required after model/state changes)
```bash
make build          # Generate Freezed and JSON serializable code
make intl           # Generate localization files
make build-all      # Run both code generation and localization
```

### Development
```bash
flutter pub get     # Install dependencies
flutter analyze     # Run linting
flutter test        # Run unit/widget tests
make test-coverage  # Generate test coverage report
```

### Building
```bash
make build-ios      # Build iOS IPA with obfuscation
make build-android  # Build Android APK with obfuscation
```

### Testing
```bash
make test-specific test=<path> device=<id>  # Run specific integration test
make test-auth-ios                          # Run iOS authentication tests
make test-auth-android                      # Run Android authentication tests
```

## Architecture

The codebase follows Clean Architecture with three layers:

### 1. UI Layer (`lib/ui/`)
- Feature-based organization (artist/, customer/, quotation/)
- Pages contain screens, widgets contain reusable components
- Navigation through `AppRoutes.onGenerateRoute` in lib/ui/shared/navigation/app_routes.dart

### 2. Domain Layer (`lib/domain/`)
- BLoCs/Cubits for state management (all states are Freezed)
- Repository interfaces (abstract classes)
- Immutable models using Freezed annotations
- Service abstractions

### 3. Data Layer (`lib/data/`)
- API communication via `HttpClientService` singleton
- Repository implementations
- Local storage: SQLite for data, SharedPreferences for settings
- Firebase integrations (Auth, FCM, Analytics)

## Key Patterns

### State Management
- Use BLoC/Cubit pattern with Freezed states
- Events trigger state changes in BLoCs
- All states must be immutable (@freezed)

### API Communication
- All API calls go through `HttpClientService`
- Endpoints defined in `lib/constants/endpoints.dart`
- Models use `fromJson/toJson` generated by json_serializable

### Dependency Injection
```dart
// Provide repositories
RepositoryProvider<Repository>(
  create: (_) => RepositoryImpl(httpClient: HttpClientService()),
)

// Provide BLoCs
BlocProvider<SomeBloc>(
  create: (context) => SomeBloc(
    repository: context.read<Repository>(),
  ),
)
```
- lib/dependencies/dependencies.dart

### Model Generation
After creating/modifying models or states:
1. Add @freezed or @JsonSerializable annotations
2. Run `make build` to generate code
3. Import the generated .g.dart and .freezed.dart files

## Important Files and Paths

### Core Configuration
- `.env` - API URL configuration
- `lib/constants/endpoints.dart` - All API endpoints
- `lib/main.dart` - App initialization and provider setup
- `lib/dependencies/dependencies.dart` - Dependency injection setup

### Navigation
- `lib/ui/shared/navigation/app_routes.dart` - Route definitions

### Theme and Styling
- `lib/ui/theme/app_theme.dart` - Theme configuration (Material 2)
- `lib/ui/views/app_view.dart` - Theme application
- Theme colors: primaryColor, colorScheme.secondary (no tertiary)

### Responsive Design
- `lib/utils/responsive/responsive_breakpoints.dart` - Breakpoint definitions
- `lib/utils/responsive/responsive_builder.dart` - Responsive widgets
- `lib/utils/responsive/responsive_theme.dart` - Theme scaling

### Platform Detection
- `lib/domain/services/platform/platform_service.dart` - Web/iOS/Android detection

### Shared UI Components
- `lib/ui/shared/widgets/buttons.dart` - PrimaryButton, SecondaryButton
- `lib/ui/shared/widgets/custom_app_bar.dart` - App bar implementation
- `lib/ui/shared/widgets/loading_widget.dart` - Loading indicators
- `lib/ui/shared/widgets/shimmer_widget.dart` - Skeleton loaders

### Authentication Flow
- `lib/ui/login/` - Login screens
- `lib/ui/register/` - Registration screens
- `lib/ui/on_boarding/` - Onboarding flow

### Key Widget Patterns
- Pages: Top-level screens (e.g., `login_page.dart`)
- Widgets: Reusable components (e.g., `login_form.dart`)
- Forms: Input handling with form_inputs package

## Code Conventions

### Event Naming in BLoCs
- Login: `OnBoardingSignInPressed`, `OnBoardingRegisterPressed`
- Navigation: `OnBoardingClearRedirect`
- State updates: Use descriptive event names

### Widget Naming
- Pages: `*Page` (e.g., `LoginPage`)
- Reusable widgets: Descriptive names (e.g., `LoginForm`, `CustomAppBar`)
- Buttons: `PrimaryButton`, `SecondaryButton` (from shared/widgets/buttons.dart)

### File Organization
- One widget per file for pages
- Group related widgets in subdirectories
- Keep forms separate from pages

### Common Imports to Remember
```dart
import 'package:inker_studio/generated/l10n.dart'; // For S.of(context)
import 'package:modal_bottom_sheet/modal_bottom_sheet.dart' show CupertinoScaffold;
```

### Notes on Existing Issues
- Some file names have typos (e.g., `sing_in_and_register_buttons.dart` instead of `sign_in`)
- Theme uses Material 2, not Material 3
- Use `colorScheme.onSurface` instead of deprecated `onBackground`
- Always check for existing shared widgets before creating new ones

## Testing Approach

- Unit tests for BLoCs and repositories in `test/`
- Integration tests using Patrol in `integration_test/`
- Mock API responses using Mockito
- Test coverage reports with `make test-coverage`

## Localization

- Primary locale: Spanish (Chile)
- Translations source: `lib/l10n/intl_*.arb` (DO NOT MODIFY - auto-generated, very large files)
- Generated localization class: `lib/generated/l10n.dart`
- Generate translations: `make intl`
- Access translations: `S.of(context).key`
- Import: `import 'package:inker_studio/generated/l10n.dart';`

## Architecture Refactoring

Two comprehensive guides have been created for future refactoring:

1. **FEATURE_BASED_REFACTORING_GUIDE.md** - Complete plan to migrate from layer-based to feature-based architecture
2. **COMPONENT_ORGANIZATION_GUIDE.md** - Strategy for organizing shared, artist-specific, and customer-specific components

These guides provide detailed migration plans, directory structures, and implementation strategies for improving the codebase organization.